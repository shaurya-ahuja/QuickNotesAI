"""
QuickNotes-AI Export Utilities
ICS calendar export and other export formats.
100% Local - No Data Leaves Your Device
"""

import os
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
import re

try:
    from icalendar import Calendar, Event, vText
    ICALENDAR_AVAILABLE = True
except ImportError:
    ICALENDAR_AVAILABLE = False


class ExportService:
    """
    Export service for meeting data.
    Supports ICS calendar files and markdown export.
    """
    
    def __init__(self, output_dir: str = "exports"):
        """
        Initialize export service.
        
        Args:
            output_dir: Directory for exported files.
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
    
    @property
    def ics_available(self) -> bool:
        """Check if ICS export is available."""
        return ICALENDAR_AVAILABLE
    
    def export_to_ics(
        self,
        action_items: List[Dict[str, Any]],
        meeting_title: str = "Meeting Actions",
        default_duration_hours: int = 1
    ) -> Optional[str]:
        """
        Export action items to ICS calendar file.
        
        Args:
            action_items: List of action items with task, deadline, assignee.
            meeting_title: Title for the calendar.
            default_duration_hours: Default event duration.
            
        Returns:
            Path to the generated ICS file, or None if failed.
        """
        if not ICALENDAR_AVAILABLE:
            raise RuntimeError("icalendar not installed. Install with: pip install icalendar")
        
        if not action_items:
            return None
        
        # Create calendar
        cal = Calendar()
        cal.add('prodid', '-//QuickNotes-AI//Meeting Actions//EN')
        cal.add('version', '2.0')
        cal.add('calscale', 'GREGORIAN')
        cal.add('method', 'PUBLISH')
        cal.add('x-wr-calname', meeting_title)
        
        events_created = 0
        
        for item in action_items:
            # Parse item (can be dict or ActionItem)
            if hasattr(item, 'task'):
                task = item.task
                deadline = item.deadline
                assignee = item.assignee
                emoji = getattr(item, 'emoji', 'ðŸ“‹')
            else:
                task = item.get('task', '')
                deadline = item.get('deadline')
                assignee = item.get('assignee')
                emoji = item.get('emoji', 'ðŸ“‹')
            
            if not task:
                continue
            
            # Parse deadline into datetime
            event_date = self._parse_deadline(deadline)
            
            if event_date is None:
                # Skip items without parseable deadlines
                continue
            
            # Create event
            event = Event()
            event.add('summary', f"{emoji} {task}")
            event.add('dtstart', event_date)
            event.add('dtend', event_date + timedelta(hours=default_duration_hours))
            event.add('dtstamp', datetime.now())
            
            # Add description
            description = f"Action Item from meeting: {meeting_title}\n\n"
            description += f"Task: {task}\n"
            if assignee:
                description += f"Assignee: {assignee}\n"
            if deadline:
                description += f"Original deadline: {deadline}\n"
            description += f"\nGenerated by QuickNotes-AI"
            
            event.add('description', description)
            
            # Add organizer if assignee specified
            if assignee:
                event.add('attendee', vText(assignee))
            
            # Generate unique ID
            event.add('uid', f"quicknotes-{datetime.now().timestamp()}-{events_created}@local")
            
            cal.add_component(event)
            events_created += 1
        
        if events_created == 0:
            return None
        
        # Save to file
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"actions_{timestamp}.ics"
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'wb') as f:
            f.write(cal.to_ical())
        
        return filepath
    
    def _parse_deadline(self, deadline: str) -> Optional[datetime]:
        """
        Parse deadline string into datetime.
        
        Handles:
        - ISO dates (2024-01-15)
        - Common formats (1/15, 01-15-2024)
        - Weekday names (Monday, Tuesday)
        - Relative terms (tomorrow, next week, ASAP)
        """
        if not deadline:
            return None
        
        deadline = deadline.strip().lower()
        now = datetime.now()
        
        # Handle relative terms
        if deadline in ['today', 'asap', 'immediately', 'urgent']:
            return now.replace(hour=17, minute=0, second=0, microsecond=0)
        
        if deadline == 'tomorrow':
            return (now + timedelta(days=1)).replace(hour=17, minute=0, second=0, microsecond=0)
        
        if 'next week' in deadline:
            return (now + timedelta(days=7)).replace(hour=17, minute=0, second=0, microsecond=0)
        
        if 'end of week' in deadline:
            days_until_friday = (4 - now.weekday()) % 7
            if days_until_friday == 0:
                days_until_friday = 7
            return (now + timedelta(days=days_until_friday)).replace(hour=17, minute=0, second=0, microsecond=0)
        
        if 'end of month' in deadline:
            # Go to first of next month, then back one day
            if now.month == 12:
                end = datetime(now.year + 1, 1, 1) - timedelta(days=1)
            else:
                end = datetime(now.year, now.month + 1, 1) - timedelta(days=1)
            return end.replace(hour=17, minute=0, second=0, microsecond=0)
        
        # Handle weekday names
        weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
        for i, day in enumerate(weekdays):
            if day in deadline:
                current_weekday = now.weekday()
                days_ahead = i - current_weekday
                if days_ahead <= 0:
                    days_ahead += 7
                return (now + timedelta(days=days_ahead)).replace(hour=17, minute=0, second=0, microsecond=0)
        
        # Try to parse as date
        date_patterns = [
            (r'(\d{4})-(\d{1,2})-(\d{1,2})', '%Y-%m-%d'),  # 2024-01-15
            (r'(\d{1,2})/(\d{1,2})/(\d{4})', '%m/%d/%Y'),  # 1/15/2024
            (r'(\d{1,2})-(\d{1,2})-(\d{4})', '%m-%d-%Y'),  # 01-15-2024
            (r'(\d{1,2})/(\d{1,2})', '%m/%d'),  # 1/15 (current year)
        ]
        
        for pattern, fmt in date_patterns:
            match = re.search(pattern, deadline)
            if match:
                try:
                    if '%Y' not in fmt:
                        # Add current year
                        date_str = f"{match.group()}/{now.year}"
                        fmt = fmt + '/%Y'
                    else:
                        date_str = match.group()
                    
                    parsed = datetime.strptime(date_str, fmt)
                    return parsed.replace(hour=17, minute=0, second=0, microsecond=0)
                except ValueError:
                    continue
        
        return None
    
    def export_to_markdown(
        self,
        meeting_title: str,
        date: str,
        transcript: str = None,
        summary: List[str] = None,
        action_items: List[Dict[str, Any]] = None,
        speaker_quotes: List[Dict[str, str]] = None,
        tags: List[str] = None
    ) -> str:
        """
        Export meeting to markdown file.
        
        Returns:
            Path to the generated markdown file.
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_title = re.sub(r'[^\w\s-]', '', meeting_title).replace(' ', '_')
        filename = f"{safe_title}_{timestamp}.md"
        filepath = os.path.join(self.output_dir, filename)
        
        lines = []
        
        # Header
        lines.append(f"# ðŸ“ {meeting_title}")
        lines.append("")
        lines.append(f"**Date:** {date}")
        
        if tags:
            lines.append(f"**Tags:** {', '.join(tags)}")
        
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # Summary
        if summary:
            lines.append("## ðŸ“Œ Summary")
            lines.append("")
            for bullet in summary:
                lines.append(f"- {bullet}")
            lines.append("")
        
        # Action Items
        if action_items:
            lines.append("## âœ… Action Items")
            lines.append("")
            for item in action_items:
                if hasattr(item, 'task'):
                    task = item.task
                    assignee = item.assignee
                    deadline = item.deadline
                    emoji = getattr(item, 'emoji', 'ðŸ“‹')
                    completed = getattr(item, 'completed', False)
                else:
                    task = item.get('task', '')
                    assignee = item.get('assignee')
                    deadline = item.get('deadline')
                    emoji = item.get('emoji', 'ðŸ“‹')
                    completed = item.get('completed', False)
                
                checkbox = "[x]" if completed else "[ ]"
                line = f"- {checkbox} {emoji} {task}"
                
                if assignee:
                    line += f" [**{assignee}**]"
                if deadline:
                    line += f" (Due: {deadline})"
                
                lines.append(line)
            lines.append("")
        
        # Speaker Quotes
        if speaker_quotes:
            lines.append("## ðŸ’¬ Key Quotes")
            lines.append("")
            for quote in speaker_quotes:
                if isinstance(quote, dict):
                    speaker = quote.get('speaker', 'Unknown')
                    text = quote.get('quote', '')
                else:
                    speaker = 'Speaker'
                    text = str(quote)
                
                lines.append(f"> **{speaker}:** \"{text}\"")
                lines.append("")
        
        # Transcript
        if transcript:
            lines.append("## ðŸ“„ Full Transcript")
            lines.append("")
            lines.append("```")
            lines.append(transcript)
            lines.append("```")
            lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("")
        lines.append("*Generated by QuickNotes-AI - 100% Local Meeting Notetaker*")
        
        # Write file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        
        return filepath
    
    def get_ics_bytes(
        self,
        action_items: List[Dict[str, Any]],
        meeting_title: str = "Meeting Actions"
    ) -> Optional[bytes]:
        """
        Get ICS content as bytes (for Streamlit download).
        
        Returns:
            ICS file content as bytes, or None if no events.
        """
        if not ICALENDAR_AVAILABLE or not action_items:
            return None
        
        # Create temporary file and read back
        filepath = self.export_to_ics(action_items, meeting_title)
        
        if filepath and os.path.exists(filepath):
            with open(filepath, 'rb') as f:
                content = f.read()
            os.remove(filepath)  # Clean up temp file
            return content
        
        return None


# Singleton instance
_service_instance: Optional[ExportService] = None


def get_export_service(output_dir: str = "exports") -> ExportService:
    """Get export service instance."""
    global _service_instance
    
    if _service_instance is None:
        _service_instance = ExportService(output_dir)
    
    return _service_instance
